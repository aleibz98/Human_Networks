## Lab assignment 2: Social network analysis and modeling

```{r}
library('igraph')
library('network')
library('intergraph')
#comments
```
```{
```

Type any R code in the chunk, for example:
```{r}
#read data from the folder data
highschool_edge<-read.csv("Human_networks/Assignment_2_kate/data/Highschool_network_edge.csv")
highschool_att <- read.csv("Human_networks/Assignment_2_kate/data/Highschool_network_att.csv")
facebook_att <- read.csv("Human_networks/Assignment_2_kate/data/Facebook_network_att.csv")
facebook_edge <- read.csv("Human_networks/Assignment_2_kate/data/Facebook_network_edge.csv")
#check that it works!
```
```{r}
highschool_att
```

```{r}
#build high school network
highschool_nodes<-data.frame(name=as.character(highschool_att$NodeID),
                  gender=as.character(highschool_att$Gender),
                  hall=as.character(highschool_att$Hall))
highschool_edges<-data.frame(from=c(as.character(highschool_edge[,1])),
                  to=c(as.character(highschool_edge[,2])))
Highschool<-graph_from_data_frame(highschool_edges,directed = FALSE,vertices = highschool_nodes)
co <- components(Highschool)
Highschool <- induced.subgraph(Highschool, which(co$membership == which.max(co$csize))) #use only the largest component for analysis
summary(Highschool)

#build facebook network
facebook_nodes<-data.frame(name=as.character(facebook_att$NodeID))
facebook_edges<-data.frame(from=c(as.character(facebook_edge[,1])),
                           to=c(as.character(facebook_edge[,2])))
Facebook<-graph_from_data_frame(facebook_edges,directed = FALSE,vertices = facebook_nodes)
summary(Facebook)
```


```{r}

#function to visualize the network (with interaction)
library(visNetwork)
set.seed(100)
Highschool_interactive_layout<-visNetwork(data.frame(id=V(Highschool)$name), highschool_edges, main = "Highschool",submain="Can zoom in/out to check the IDs and ties") %>%
  visIgraphLayout(layout = "layout_nicely",smooth =  FALSE) %>%
  visNodes(shape="circle",label = TRUE) %>%
  visOptions(highlightNearest = list(enabled = T, hover = T), nodesIdSelection = T)

Highschool_interactive_layout

```
```{r}

# find the node of he hisghest degree
#degree(Highschool)
which.max(degree(Highschool))
V(Highschool)[which.max(degree(Highschool))]

```
```{r}
#find the node of the highest betweenness centrality
#
which.max(betweenness(Highschool))
V(Highschool)[which.max(betweenness(Highschool))]

```
```{r}
#find the node of the highest closeness centrality
#closeness(Highschool)
which.max(closeness(Highschool))
V(Highschool)[which.max(closeness(Highschool))]

```
```{r}
#find the node with the highest eigen
eigen_centrality(Highschool)
V(Highschool)[which.max(eigen_centrality(Highschool))] #110
#
# #the highest degree node is 110
#
# #find the maximum in data frame
# max(eigen_centrality(Highschool))
```


Question 2 (5 points):
•	Study the correlations between a) degree and betweenness, b) degree and closeness, c) degree and eigenvector for all the nodes in the Highschool network;
•	Study the correlations between a) degree and betweenness, b) degree and closeness, c) degree and eigenvector for all the nodes in the Facebook network;
•	From the above results, how well do different metrics correlate with each other? Which centrality metric will you use and why?
Please provide more than just a correlation coefficient to answer Question 2. You are suggested to study the correlations by developing a scatter plot as below, in which every dot represents a node in the network, with xlab as degree and ylab as closeness.
```{r}
#check the correlation between degree and betweenness
cor.test(degree(Highschool),betweenness(Highschool))
```
```{r}
#check the correlation between degree and closeness
cor.test(degree(Highschool),closeness(Highschool))
```
```{r}
#check the correlation between degree and eigenvector
eigen_hs <- eigen_centrality(Highschool)$vector
cor.test(degree(Highschool),eigen_hs)
```
```{r}
#check the correlation between degree and betweenness
cor.test(degree(Facebook),betweenness(Facebook))
```
```{r}
#check the correlation between degree and closeness
cor.test(degree(Facebook),closeness(Facebook))
```
```{r}
#check the correlation between degree and eigenvector and add the trand line
eigen_fb <- eigen_centrality(Facebook)$vector
cor.test(degree(Facebook),eigen_fb)
```
```{r}
# cor.test(degree(Facebook),eigen_centrality(Facebook))
#add the trand line to the plot
# abline(lm(degree(Highschool)~betweenness(Highschool)),col="red")

#make a scatter plot for degree and closeness and add the trand line
plot(degree(Highschool),closeness(Highschool),xlab="Degree",ylab="Closeness")
abline(lm(closeness(Highschool)~degree(Highschool)),col="red")
#make the confident interval for the trand line with grey color
```



```{r}
#make a scatter plot for degree and closeness for Facebook
plot(degree(Highschool),betweenness(Highschool),xlab="Degree",ylab="Closeness")
abline(lm(closeness(Highschool)~degree(Highschool)),col="red")
```
```{r}
#make a scatter plot for degree and closeness for Facebook
plot(degree(Facebook),closeness(Facebook),xlab="degree",ylab="closeness")
abline(lm(closeness(Facebook)~degree(Facebook)),col="red")
```
```{r}
# calculate the shortest path lengths between every pair of two nodes in Highschool network

distances(
  Highschool,
  v = V(Highschool),
  to = V(Highschool),
  mode = c("all", "out", "in"),
  weights = NULL) #Shortest path lengths between every pair of two nodes in the network

```
```{r}
#make a histogram of the shortest path lengths between every pair of two nodes in Highschool network with percentiles
hist(distances(Highschool),xlab="shortest path length",ylab="% of total cout by group",main="Histogram of the shortest path lengths between every pair of two nodes in Highschool network",breaks=10,prob=T)
#add percentiles and add the value of the percentiles to the plot
abline(v=quantile(distances(Highschool),c(0.25,0.5,0.75)),col="red")
text(quantile(distances(Highschool),c(0.25,0.5,0.75)),c(0.1,0.1,0.1),labels=quantile(distances(Highschool),c(0.25,0.5,0.75)),col="red")
```
```{r}
hist(distances(Facebook),xlab="shortest path length",ylab="% of total cout by group",main="Histogram of the shortest path lengths between every pair of two nodes in Facebook network",breaks=10,prob=T)
#add percentiles and add the value of the percentiles to the plot
abline(v=quantile(distances(Facebook),c(0.25,0.5,0.75)),col="red")
text(quantile(distances(Facebook),c(0.25,0.5,0.75)),c(0.1,0.1,0.1),labels=quantile(distances(Facebook),c(0.25,0.5,0.75)),col="red")
```


Test the above hypothesis by the following steps (Question 4, 4 points):
```{r}
#visualize the Highschool network by gender
library(RColorBrewer)
coul  <- brewer.pal(length(unique( V(Highschool)$gender)), "Set2")
my_color <- coul[as.numeric(as.factor(V(Highschool)$gender))]
set.seed(10)
plot(Highschool, vertex.color = my_color,
     vertex.size=5,
     layout=layout.fruchterman.reingold(Highschool),vertex.label=NA,
     main="Highschool network by gender")
#add the legend of the color of the nodes at the top left corner
legend("bottomleft", legend=levels(as.factor(V(Highschool)$gender)) ,col = coul , bty = "n", pch=200 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))
```
```{r}
#visualize the Highschool network by residentil area
coul  <- brewer.pal(length(unique(V(Highschool)$hall)), "Set2")
my_color <- coul[as.numeric(as.factor(V(Highschool)$hall))]
set.seed(10)
plot(Highschool, vertex.color = my_color,
     vertex.size=5,
     layout=layout.fruchterman.reingold(Highschool),vertex.label=NA,
     main="Highschool network by Hall")
#add the legend of the color of the nodes at the top left corner
legend("bottomleft", legend=levels(as.factor(V(Highschool)$gender)) ,col = coul , bty = "n", pch=20 , pt.cex = 1.5, cex = 1.5, horiz = FALSE, inset = c(0.1, 0.1))
```
```{r}
#introduce subgraph by gender = F, calculate their edge densities
group_female <- as.factor(unique(V(Highschool)$gender=='female'))
sapply(levels(group_female), function(x) {
  y <- induced_subgraph(Highschool, which(V(Highschool)$gender==x))
  paste0("Density for ", x, " friends is ", edge_density(y))
})



```
```{r}
group <- as.factor(unique(V(Highschool)$hall))
sapply(levels(group), function(x) {
  y <- induced_subgraph(Highschool, which(V(Highschool)$hall==x))
  paste0("Density for ", x, " friends is ", edge_density(y))
})
```
```{r}
#introduce subgraph by gender, calculate their edge densities
group <- as.factor(unique(V(Highschool)$gender))
sapply(levels(group), function(x) {
  y <- induced_subgraph(Highschool, which(V(Highschool)$gender==x))
  paste0("Density for ", x, " friends is ", edge_density(y))
})

```
Question 5 (4 points):
1)	Calculate the modularity of the Highschool network if community is merely identified by a) gender and b) residential hall, respectively.
2)	Search the Louvain Community Detection and explain the algorithm in your own words.
3)	Use the Louvain Community Detection to identify communities in the Highschool network. Compare the modularity value produced by the Louvain algorithm to those in 1), and explain the reasons for the differences.
```{r}
### customize community by gender

genderCommunity<-V(Highschool)$gender
genderCommunity<-replace(genderCommunity,genderCommunity=="female",1)
genderCommunity<-replace(genderCommunity,genderCommunity=="male",2)
genderCommunity<-replace(genderCommunity,genderCommunity=="unknown",3)
genderCommunity<-as.numeric(genderCommunity)

gender.clustering <- make_clusters(Highschool, membership=genderCommunity)
modularity(gender.clustering)

```
```{r}
### customize community by hall
hallCommunity<-V(Highschool)$hall
hallCommunity<-replace(hallCommunity,hallCommunity=="1501",1)
hallCommunity<-replace(hallCommunity,hallCommunity=="1502",2)
hallCommunity<-replace(hallCommunity,hallCommunity=="1503",3)
hallCommunity<-replace(hallCommunity,hallCommunity=="1504",4)
hallCommunity<-replace(hallCommunity,hallCommunity=="1505",5)
hallCommunity<-as.numeric(hallCommunity)

hall.clustering <- make_clusters(Highschool, membership=hallCommunity)
modularity(hall.clustering)

```
```{r}
### Louvain algorithm ###
Louv<-cluster_louvain(Highschool)
modularity(Louv)

```
```{r}
### Louvain algorithm ###
Louv<-cluster_louvain(Facebook)
modularity(Louv)
```
Exercise two: Network formation models
Network relationships come in many shapes and sizes, and so there is no single model which encompasses them all.
But over time, people do summarize some common paradigm that can be used to build a synthetic network.
In the lecture, we mentioned three major architectures to build a synthetic network, which is Erdos-Renyi Random Graph Model,
Small-world Random Graph Model, and Barabasi-Albert (BA) model.


```{r}
sample_gnp(20, 0.1, directed = FALSE, loops = FALSE)
#visualize the network
plot(sample_gnp(20, 0.1, directed = FALSE, loops = FALSE),vertex.label=NA)
#add the name of the plot
title(main="ER1")
```
```{r}
ER1 <-sample_gnp(20, 0.1, directed = FALSE, loops = FALSE)
plot((ER1), vertex.label=NA)
#add the name of the plot
title(main="ER1")
```
```{r}

ER2 <- sample_gnp(20, 0.2, directed = FALSE, loops = FALSE)
plot((ER2),vertex.label=NA)
#add the name of the plot
title(main="ER2")
```
```{r}
ER3 <-sample_gnp(20, 0.3, directed = FALSE, loops = FALSE)
plot((ER2),vertex.label=NA)
#add the name of the plot
title(main="ER3")
```
```{r}
#average degree of the ER1
mean(degree(ER1))
```
```{r}
mean(degree(ER2))
```
```{r}
mean(degree(ER3))
```
```{r}
#minimum degree of the ER1
min(degree(ER1))
```
```{r}
min(degree(ER2))
```
```{r}
min(degree(ER3))
```
```{r}
#maximum degree of the ER1
max(degree(ER1))
```
```{r}
max(degree(ER2))
```
```{r}
max(degree(ER3))
```
```{r}
ER1000 <-sample_gnp(1000, 0.1, directed = FALSE, loops = FALSE)
plot((ER1000), vertex.label=NA)
#add the name of the plot
title(main="ER1000")

```
```{r}
transitivity(ER1000)
```
```{r}
ER1000_2 <-sample_gnp(1000, 0.2, directed = FALSE, loops = FALSE)
ER1000_3 <-sample_gnp(1000, 0.3, directed = FALSE, loops = FALSE)
ER1000_4 <-sample_gnp(1000, 0.4, directed = FALSE, loops = FALSE)
ER1000_5 <-sample_gnp(1000, 0.5, directed = FALSE, loops = FALSE)
ER1000_9 <-sample_gnp(1000, 0.9, directed = FALSE, loops = FALSE)
# plot((ER1000_2), vertex.label=NA)
#add the name of the plot
# title(main="ER1000_2")

```
```{r}
# transitivity(ER1000_2)
transitivity(ER1000_9)
```
```{r}
Regular<-watts.strogatz.game(dim=1,size=300,nei=6, p=0)
plot(Regular, layout=layout.circle, vertex.label=NA, vertex.size=5, main= "Network with zero rewiring probability ")
SW1<-watts.strogatz.game(dim=1,size=300,nei=6, p=0.001)
plot(SW1, layout=layout.circle, vertex.label=NA, vertex.size=5, main= "Network with 0.001 rewiring probability ")
SW2<-watts.strogatz.game(dim=1,size=300,nei=6, p=0.01)
plot(SW2, layout=layout.circle, vertex.label=NA, vertex.size=5, main= "Network with 0.01 rewiring probability ")
SW3<-watts.strogatz.game(dim=1,size=300,nei=6, p=0.1)
plot(SW3, layout=layout.circle, vertex.label=NA, vertex.size=5, main= "Network with 0.1 rewiring probability ")

```
```{r}
transitivity(Regular)
```
```{r}
transitivity(SW1)
```
```{r}
transitivity(SW2)
```
```{r}
transitivity(SW3)
```
```{r}
#calculate teh averahe path length
mean_distance(Regular)
```
```{r}
mean_distance(SW1)
```
```{r}
mean_distance(SW2)
```
```{r}
mean_distance(SW3)

```
Question 8
```{r}

```
